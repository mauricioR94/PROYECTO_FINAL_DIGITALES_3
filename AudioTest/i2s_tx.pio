.program i2s_tx
.side_set 2

; side-set bit0 -> BCLK
; side-set bit1 -> LRCK

; Se esperan 32 bits por frame (16 izquierda, 16 derecha),
; MSB primero. Datos en un solo pin (DIN).

.wrap_target
    ; Canal izquierdo: LRCK = 0
    set x, 15         side 0b01   ; LRCK=0, BCLK=1 (estado inicial)

left_loop:
    out pins, 1       side 0b00   ; BCLK=0, sacar bit
    jmp x-- left_loop side 0b01   ; BCLK=1, siguiente bit

    ; Canal derecho: LRCK = 1
    set x, 15         side 0b11   ; LRCK=1, BCLK=1

right_loop:
    out pins, 1       side 0b10   ; BCLK=0, LRCK=1
    jmp x-- right_loop side 0b11  ; BCLK=1, LRCK=1
.wrap

% c-sdk {
static inline void i2s_tx_program_init(PIO pio, uint sm, uint offset,
                                       uint data_pin, uint bclk_pin) {
    pio_sm_config c = i2s_tx_program_get_default_config(offset);

    // Un pin de datos
    sm_config_set_out_pins(&c, data_pin, 1);

    // Dos pines consecutivos para side-set: BCLK (base) y LRCK (base+1)
    sm_config_set_sideset_pins(&c, bclk_pin);

    // Shift a la izquierda, autopull cada 32 bits (un frame est√©reo)
    sm_config_set_out_shift(&c, true, true, 32);

    // Inicializar GPIOs para uso con PIO
    pio_gpio_init(pio, data_pin);
    pio_gpio_init(pio, bclk_pin);
    pio_gpio_init(pio, bclk_pin + 1);

    uint32_t pin_mask = (1u << data_pin)
                      | (1u << bclk_pin)
                      | (1u << (bclk_pin + 1));

    pio_sm_set_pindirs_with_mask(pio, sm, pin_mask, pin_mask);

    // Inicializar la state machine
    pio_sm_init(pio, sm, offset, &c);
}
%}
